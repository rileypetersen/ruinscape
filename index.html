<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Optimal Bet Strategy</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', sans-serif; margin: 20px; }
    input, button, select, textarea { font-family: 'Inter', sans-serif; }
    fieldset { margin-bottom: 20px; }
    .inputRow { margin-bottom: 10px; }
    label { display: inline-block; width: 320px; }
    input[type="text"] { width: 100px; }
    input[type="checkbox"] { vertical-align: middle; }
    #results { margin-top: 20px; padding: 10px; border: 1px solid #ccc; }
    #resultSummary { margin-bottom: 20px; }
    .error { color: red; font-weight: bold; }
    .notice { color: blue; font-weight: bold; }
    button { margin-right: 10px; font-family: 'Inter', sans-serif; }
    table { border-collapse: collapse; margin-top: 20px; font-size: 12px; }
    table, th, td { border: 1px solid black; }
    th, td { padding: 5px; text-align: center; }
    @media screen and (max-width: 960px) {
      #topRow { flex-direction: column !important; }
      #topRow fieldset, #advancedSection fieldset { box-sizing: border-box; width: 100% !important; margin: 0 0 20px 0 !important; border: 1px solid #ccc !important; padding: 10px !important; }
    }
  </style>
</head>
<body>
  <!-- <h2>Dice Strategy Generator</h2> -->
  <div id="topRow" style="display: flex; flex-direction: row; align-items: flex-start; gap: 20px; width: 100%;">
    <fieldset style="width: 50%;">
      <legend>Base Parameters</legend>
      <div class="inputRow">
        <label for="B">Bankroll (B):</label>
        <input type="text" id="B" value="100">
      </div>
      <div class="inputRow">
        <label for="rpr">Ruin Probability Requirement (RPR):</label>
        <input type="text" id="rpr" value="1%">
      </div>
      <div class="inputRow">
        <label for="gc" style="font-size: 11px;">Use GC Minimum Bet (0.11 instead of 0.01):</label>
        <input type="checkbox" id="gc">
      </div>
      <button onclick="simulateOptimalStrategy()">Find Optimal Strategy</button>
      <button id="toggleAdvanced" onclick="toggleAdvanced()">â–º Advanced</button>
    </fieldset>
    
    <fieldset id="setupSection" style="width: 50%; border: 1px solid #ccc; padding: 10px;">
      <legend>Setup</legend>
      <div id="setupContent">Setup info will appear here upon calculation</div>
    </fieldset>
  </div>
  
  <!-- Advanced Section (hidden by default) -->
  <div id="advancedSection" style="display: none;">
    <fieldset>
      <legend>Computed/Locked Parameters</legend>
      <div class="inputRow">
        <label for="p_win">Win Probability (p_win):</label>
        <input type="text" id="p_win" value="49.5">
      </div>
      <div class="inputRow">
        <label for="r">Game Payout Multiplier (r_game):</label>
        <input type="text" id="r">
      </div>
      <div class="inputRow">
        <label for="minIncrease">Chosen IOL (%):</label>
        <input type="text" id="minIncrease" value="100">
        <input type="checkbox" id="lock_minIncrease">
        <span class="locked"> Lock</span>
      </div>
      <div class="inputRow">
        <label for="L">Maximum Series Length (L):</label>
        <input type="text" id="L" value="">
        <input type="checkbox" id="lockL">
        <span class="locked"> Lock</span>
      </div>
      <div class="inputRow">
        <label for="N">Waiting Trigger (N):</label>
        <input type="text" id="N" value="">
        <input type="checkbox" id="lockN">
        <span class="locked"> Lock</span>
      </div>
      <div class="inputRow">
        <label for="S">Starting Bet (S):</label>
        <input type="text" id="S" value="">
        <input type="checkbox" id="lockS">
        <span class="locked"> Lock</span>
      </div>
      <button onclick="calculateOptimalStrategy()">Calculate</button>
    </fieldset>
  </div>

  <!-- Removed old Computed/Locked Parameters fieldset and standalone Calculate button -->

  <div id="results"></div>
  
  <script>
    // Helper: round to given decimals.
    function roundTo(num, decimals) {
      return Number(Math.round(num + "e" + decimals) + "e-" + decimals);
    }
    
    // Add helper functions for decimal arithmetic (rounded to 8 decimals) near the top of the script, after roundTo:
    function decMul(a, b) {
      return Number((a * b).toFixed(8));
    }

    function decAdd(a, b) {
      return Number((a + b).toFixed(8));
    }
    
    // --- Core Model Computation ---
    // This function computes all parameters given a candidate p_win and IOL.
    // p_win is in percent.
    // IOL (in percent) is a free variable that must be >= IOL_min = 100/(r_game-1).
    function computeParametersCandidate(p_win, IOL) {
      let errors = [];
      
      // User inputs:
      let B = parseFloat(document.getElementById("B").value);
      let RPR_raw = document.getElementById("rpr").value.replace("%", "");
      let RPR = parseFloat(RPR_raw) / 100;  // e.g., 0.001000% becomes 0.00001.
      let S_min = document.getElementById("gc").checked ? 0.11 : 0.01;
      
      if (isNaN(B) || B <= 0) errors.push("Bankroll (B) must be a positive number.");
      if (isNaN(p_win) || p_win < 2 || p_win > 98) errors.push("Candidate p_win must be between 2% and 98%.");
      if (isNaN(RPR) || RPR <= 0 || RPR >= 1) errors.push("RPR must be a fraction (e.g., 0.001000%).");
      
      let p_win_frac = p_win / 100;
      let p_loss = 1 - p_win_frac;
      
      // Compute r_game from RTP:
      let r_game = 99 / p_win;
      
      // Compute the minimum IOL required:
      let IOL_min = 100 / (r_game - 1);
      if (IOL < IOL_min) {
        errors.push("Candidate IOL must be at least " + IOL_min.toFixed(2) + "% to sustain losses.");
      }
      
      // Use free variable IOL to define the escalation multiplier:
      let r_opt = 1 + (IOL / 100);
      
      // Maximum series length L (using r_opt):
      let L = Math.floor(Math.log(B / S_min + 1) / Math.log(r_opt));
      if (L < 1) L = 1;
      
      // Waiting trigger N: set such that overall ruin probability = (p_loss)^(N+L) <= RPR.
      // Solve for N: N >= ceil( ln(RPR)/ln(p_loss) ) - L.
      let N = Math.max(0, Math.ceil(Math.log(RPR) / Math.log(p_loss)) - L);
      
      // Starting bet S:
      let S = B / (Math.pow(r_opt, L) - 1);
      
      // Overall ruin probability:
      let overallRuinProb = Math.pow(p_loss, N + L);
      
      // Final remaining balance if all bets lose:
      // Total bets = S*(r_opt^L - 1)/(r_opt - 1), so final balance = B - [this amount] = B*(r_opt - 2)/(r_opt - 1)
      let finalBalance = B * (r_opt - 2) / (r_opt - 1);
      
      return {
        errors: errors,
        B: B,
        RPR: RPR,
        S_min: S_min,
        p_win: p_win,
        p_loss: p_loss,
        r_game: r_game,
        IOL: IOL,
        IOL_min: IOL_min,
        r_opt: r_opt,
        L: L,
        N: N,
        S: S,
        overallRuinProb: overallRuinProb,
        overallRuinPercent: overallRuinProb * 100,
        likelihood: Math.round(1 / overallRuinProb),
        p_win_frac: p_win_frac,
        finalBalance: finalBalance
      };
    }
    
    // --- Display Results ---
    function displayResults(params) {
      const resultsDiv = document.getElementById("results");
      
      let summaryHtml = "<h3 style='margin-top:0;'>Results</h3>";
      summaryHtml += "<div style='font-size:0.8em;'>";
      summaryHtml += "<p><strong>Bankroll (B):</strong> " + params.B + "</p>";
      summaryHtml += "<p><strong>Ruin Probability Requirement (RPR):</strong> " + (params.RPR * 100).toFixed(6) + "%</p>";
      summaryHtml += "<p><strong>Optimal Win Probability (p_win):</strong> " + params.p_win.toFixed(1) + "%</p>";
      summaryHtml += "<p><strong>Game Payout Multiplier (r_game):</strong> " + params.r_game.toFixed(4) + "</p>";
      summaryHtml += "<p><strong>Chosen IOL:</strong> " + params.IOL.toFixed(2) + "% (Minimum required: " + params.IOL_min.toFixed(2) + "%)</p>";
      summaryHtml += "<p><strong>Optimal Escalation Multiplier (r_opt):</strong> " + params.r_opt.toFixed(4) + "</p>";
      summaryHtml += "<p><strong>Maximum Series Length (L):</strong> " + params.L + "</p>";
      summaryHtml += "<p><strong>Waiting Trigger (N):</strong> " + params.N + "</p>";
      summaryHtml += "<p><strong>Starting Bet (S):</strong> " + params.S.toFixed(2) + "</p>";
      summaryHtml += "<p><strong>Overall Ruin Probability:</strong> " + (params.overallRuinProb * 100).toFixed(6) + "%</p>";
      summaryHtml += "<p><strong>Likelihood of Ruin:</strong> 1/" + params.likelihood + "</p>";
      summaryHtml += "<p><strong>Final Remaining Balance (if all bets lose):</strong> " + params.finalBalance.toFixed(2) + "</p>";

      // Updated expected games calculation using reciprocal of overallRuinProb
      let expectedGames = 1 / params.overallRuinProb;
      summaryHtml += "<p><strong>Expected Games Until Ruin:</strong> " + expectedGames.toFixed(0) + "</p>";

      let setupHtml = "Set win chance to " + params.p_win.toFixed(1) + "%<br>";
      if (params.N > 0) {
          setupHtml += "Set base bet to 0.00<br>";
          setupHtml += "<ul>";
          setupHtml += "<li><strong>Custom</strong></li>";
          setupHtml += "<li>Streak greater than " + params.N + " losses, Increase amount " + params.IOL.toFixed(2) + "%</li>";
          setupHtml += "<li>First streak of " + params.N + " losses, set amount to " + params.S.toFixed(2) + "</li>";
          setupHtml += "<li>Every 1 win, reset amount</li>";
          setupHtml += "</ul>";
      } else {
          setupHtml += "<ul>";
          setupHtml += "<li><strong>Auto</strong></li>";
          setupHtml += "<li>Starting bet = " + params.S.toFixed(2) + "</li>";
          setupHtml += "<li>Increase on loss = " + params.IOL.toFixed(2) + "%</li>";
          setupHtml += "</ul>";
      }

      document.getElementById("setupContent").innerHTML = setupHtml;
      document.getElementById("setupSection").style.display = 'block';
      
      let summaryDisplayHtml = "<div id='resultSummary'>" + summaryHtml + "</div>";
      
      let tableHtml = buildSimulationTable(params);
      
      let explanationHtml = "<div id='explanation' style='margin-top:20px; padding:10px; border:1px solid #ccc; background-color:#f9f9f9;'>";
      explanationHtml += "<h4>Order of Operations:</h4>";
      explanationHtml += "<ol>";
      explanationHtml += "<li>RTP is fixed at 99%, so the game payout multiplier is calculated as r_game = 99 / p_win.</li>";
      explanationHtml += "<li>The candidate Increase-On-Loss (IOL) must be at least IOL_min = 100 / (r_game - 1) to ensure recoverability.</li>";
      explanationHtml += "<li>The escalation multiplier is computed as r_opt = 1 + (IOL / 100).</li>";
      explanationHtml += "<li>The maximum series length is L = floor( ln(B/S_min + 1) / ln(r_opt) ), where S_min is the minimum bet (0.11 if GC is used, otherwise 0.01). If L is less than 1, it is set to 1.</li>";
      explanationHtml += "<li>The waiting trigger is determined as N = max(0, ceil( ln(RPR) / ln(1 - p_win/100) ) - L), ensuring that the overall ruin probability (p_loss)^(N+L) does not exceed RPR, with p_loss = 1 - p_win/100.</li>";
      explanationHtml += "<li>The starting bet is S = B / (r_opt^L - 1).</li>";
      explanationHtml += "<li>If all bets are lost, the final remaining balance is B*(r_opt - 2)/(r_opt - 1).</li>";
      explanationHtml += "<li>The simulation iterates candidate pairs (p_win and IOL) and selects the one that minimizes the final remaining balance while meeting the RPR threshold, preferring candidates with N = 0 when available.</li>";
      explanationHtml += "</ol>";
      explanationHtml += "</div>";
      
      let resultContainer = "<div id='resultContainer' style='display: flex; flex-wrap: wrap; align-items: flex-start; gap: 20px;'>" +
                            "<div id='resultTableContainer' style='flex: 1 1 auto;'>" + tableHtml + "</div>" +
                            "<div id='resultSummaryContainer' style='flex: 1 1 300px;'>" + summaryDisplayHtml + "</div>" +
                            "</div>";
      
      resultsDiv.innerHTML = resultContainer + explanationHtml;
    }
    
    // --- Build Simulation Table ---
    // This table shows the complete loss streak:
    // First N rounds are "waiting" rounds (0 bets), then L rounds of actual bets.
    function buildSimulationTable(params) {
      let html = "<h3 style='margin-top:0;'>Loss Streak Simulation</h3>";
      html += "<table><tr>";
      html += "<th>Round #</th>";
      html += "<th>Bet Size</th>";
      html += "<th>Cumulative Bet</th>";
      html += "<th>Bet+</th>";
      html += "<th>Payout on Win</th>";
      html += "<th>Remaining Balance</th>";
      html += "<th>Balance+</th>";
      html += "</tr>";
      
      // Round the initial bet for UI display (S0 already rounded to two decimals)
      let S0 = Number(params.S.toFixed(2));
      
      // Waiting rounds (N rounds): round all numeric UI values
      for (let i = 1; i <= params.N; i++) {
        html += "<tr>";
        html += "<td>" + i + " (Wait)</td>";
        html += "<td>" + (0).toFixed(2) + "</td>";
        html += "<td>" + (0).toFixed(2) + "</td>";
        // For waiting rounds, if lost, the next bet would be S0:
        html += "<td>" + S0.toFixed(2) + "</td>";
        html += "<td>N/A</td>";
        html += "<td>" + params.B.toFixed(2) + "</td>";
        html += "<td>" + (params.B - S0).toFixed(2) + "</td>";
        html += "</tr>";
      }
      
      // Actual betting rounds (L rounds): round UI values to 2 decimals
      let cumulative = 0;
      for (let j = 1; j <= params.L; j++) {
        // Compute current bet using S0
        let currentBet = S0 * Math.pow(params.r_opt, j - 1);
        cumulative = cumulative + currentBet;
        let nextBet = S0 * Math.pow(params.r_opt, j);
        let betPlus = cumulative + nextBet;
        let payout = nextBet;
        let balance = params.B - cumulative;
        let balancePlus = params.B - betPlus;

        html += "<tr>";
        html += "<td>" + (params.N + j) + "</td>";
        html += "<td>" + currentBet.toFixed(2) + "</td>";
        html += "<td>" + cumulative.toFixed(2) + "</td>";
        html += "<td>" + betPlus.toFixed(2) + "</td>";
        html += "<td>" + payout.toFixed(2) + "</td>";
        html += "<td>" + balance.toFixed(2) + "</td>";
        html += "<td>" + balancePlus.toFixed(2) + "</td>";
        html += "</tr>";
      }
      
      html += "</table>";
      return html;
    }
    
    // --- Main Calculate Function (for manual calculation) ---
    function calculateOptimalStrategy() {
      let params = computeParametersCandidate(parseFloat(document.getElementById("p_win").value),
                                              parseFloat(document.getElementById("minIncrease").value));
      if (params.errors.length > 0) {
        document.getElementById("results").innerHTML = "<p class='error'>" + params.errors.join(" ") + "</p>";
        return;
      }
      displayResults(params);
    }
    
    // --- Simulation Optimization ---
    // Updated version that prioritizes minimal N, then finalBalance:
    function simulateOptimalStrategy() {
      let bestCandidate = { p_win: null, IOL: null };
      let bestCandidateN = Infinity;
      let bestFinalBalance = Infinity;
      let candidateParams;
      // Iterate candidate win probabilities from 2% to 98%
      for (let p = 2; p <= 98; p += 0.1) {
        let r_game = 99 / p;
        let IOL_min = 100 / (r_game - 1);
        for (let IOL = Math.ceil(IOL_min); IOL <= IOL_min + 500; IOL += 0.5) {
          candidateParams = computeParametersCandidate(p, IOL);
          if (candidateParams.errors.length > 0) continue;
          if (candidateParams.overallRuinProb > candidateParams.RPR) continue;
          if (candidateParams.r_opt <= 2) continue;
          // Prefer candidates that do not require any waiting rounds (N == 0).
          if (candidateParams.N === 0) {
              // If we haven't selected a candidate with N == 0 yet, or found one with a lower final balance
              if (bestCandidateN !== 0 || candidateParams.finalBalance < bestFinalBalance) {
                  bestCandidateN = 0;
                  bestFinalBalance = candidateParams.finalBalance;
                  bestCandidate.p_win = p;
                  bestCandidate.IOL = IOL;
              }
          } else if (bestCandidateN !== 0 && (candidateParams.N < bestCandidateN ||
                       (candidateParams.N === bestCandidateN && candidateParams.finalBalance < bestFinalBalance))) {
              bestCandidateN = candidateParams.N;
              bestFinalBalance = candidateParams.finalBalance;
              bestCandidate.p_win = p;
              bestCandidate.IOL = IOL;
          }
        }
      }

      if (bestCandidate.p_win !== null) {
        let finalParams = computeParametersCandidate(bestCandidate.p_win, bestCandidate.IOL);
        displayResults(finalParams);
      } else {
        alert("No candidate combination meets the criteria.");
      }
    }

    function updateRGame() {
      let new_pwin = parseFloat(document.getElementById("p_win").value);
      if (!isNaN(new_pwin) && new_pwin > 0) {
        // Update slider if it exists
        let slider = document.getElementById("p_win_slider");
        if (slider) {
          slider.value = new_pwin;
        }
        let sliderVal = document.getElementById("p_win_slider_val");
        if (sliderVal) {
          sliderVal.textContent = new_pwin.toFixed(1) + "%";
        }
        // Calculate and update r_game
        let r_game = 99 / new_pwin;
        let rElement = document.getElementById("r");
        if (rElement) {
          rElement.value = r_game.toFixed(4);
        }
        // If minIncrease is not locked, update it
        let lockMinIncrease = document.getElementById("lock_minIncrease");
        let minIncreaseElem = document.getElementById("minIncrease");
        if (lockMinIncrease && !lockMinIncrease.checked && minIncreaseElem) {
          let computedMinIncrease = 100 / (r_game - 1);
          minIncreaseElem.value = computedMinIncrease.toFixed(2);
        }
      }
    }

    // Remove previous listeners and override with oninput and onchange assignments:
    document.getElementById("p_win").oninput = updateRGame;
    document.getElementById("p_win").onchange = updateRGame;
    updateRGame();

    // --- Toggle Advanced Section ---
    function toggleAdvanced() {
      var adv = document.getElementById("advancedSection");
      var toggleBtn = document.getElementById("toggleAdvanced");
      if (adv.style.display === "none") {
        adv.style.display = "block";
        toggleBtn.textContent = "â–¼ Advanced";
      } else {
        adv.style.display = "none";
        toggleBtn.textContent = "â–º Advanced";
      }
    }
  </script>
</body>
</html>
