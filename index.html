<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Optimal Bet Strategy</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    fieldset { margin-bottom: 20px; }
    .inputRow { margin-bottom: 10px; }
    label { display: inline-block; width: 320px; }
    input[type="text"] { width: 100px; }
    #results { margin-top: 20px; padding: 10px; border: 1px solid #ccc; }
    #resultSummary { margin-bottom: 20px; }
    .error { color: red; font-weight: bold; }
    .notice { color: blue; font-weight: bold; }
    button { margin-right: 10px; }
    table { border-collapse: collapse; margin-top: 20px; font-size: 12px; }
    table, th, td { border: 1px solid black; }
    th, td { padding: 5px; text-align: center; }
  </style>
</head>
<body>
  <h2>Optimal Bet Strategy</h2>
  
  <!-- Base Parameters: Only Bankroll and RPR are inputs (plus GC for Sₘᵢₙ) -->
  <fieldset>
    <legend>Base Parameters</legend>
    <div class="inputRow">
      <label for="B">Bankroll (B):</label>
      <input type="text" id="B" value="555">
    </div>
    <div class="inputRow">
      <label for="rpr">Ruin Probability Requirement (RPR):</label>
      <input type="text" id="rpr" value="0.001000%">
      <span>(e.g., 0.001000% for 0.001%)</span>
    </div>
    <div class="inputRow">
      <label for="gc">Use GC Minimum Bet (1.00 instead of 0.01):</label>
      <input type="checkbox" id="gc">
    </div>
  </fieldset>
  
  <!-- Computed/Locked Parameters Section (Displayed so user can see them) -->
  <fieldset>
    <legend>Computed/Locked Parameters</legend>
    <div class="inputRow">
      <label for="p_win">Win Probability (p_win):</label>
      <input type="text" id="p_win" value="50">
    </div>
    <div class="inputRow">
      <label for="r">Game Payout Multiplier (r_game):</label>
      <input type="text" id="r" value="1.9800">
    </div>
    <div class="inputRow">
      <label for="minIncrease">Chosen IOL (%):</label>
      <input type="text" id="minIncrease" value="0">
      <input type="checkbox" id="lock_minIncrease">
      <span class="locked"> Lock</span>
    </div>
    <div class="inputRow">
      <label for="L">Maximum Series Length (L):</label>
      <input type="text" id="L" value="">
      <input type="checkbox" id="lockL">
      <span class="locked"> Lock</span>
    </div>
    <div class="inputRow">
      <label for="N">Waiting Trigger (N):</label>
      <input type="text" id="N" value="">
      <input type="checkbox" id="lockN">
      <span class="locked"> Lock</span>
    </div>
    <div class="inputRow">
      <label for="S">Starting Bet (S):</label>
      <input type="text" id="S" value="">
      <input type="checkbox" id="lockS">
      <span class="locked"> Lock</span>
    </div>
  </fieldset>
  
  <!-- Buttons -->
  <button onclick="calculateOptimalStrategy()">Calculate Optimal Strategy</button>
  <button onclick="simulateOptimalStrategy()">Simulate Optimal Strategy</button>
  
  <div id="results"></div>
  
  <script>
    // Helper: round to given decimals.
    function roundTo(num, decimals) {
      return Number(Math.round(num + "e" + decimals) + "e-" + decimals);
    }
    
    // --- Core Model Computation ---
    // This function computes all parameters given a candidate p_win and IOL.
    // p_win is in percent.
    // IOL (in percent) is a free variable that must be >= IOL_min = 100/(r_game-1).
    function computeParametersCandidate(p_win, IOL) {
      let errors = [];
      
      // User inputs:
      let B = parseFloat(document.getElementById("B").value);
      let RPR_raw = document.getElementById("rpr").value.replace("%", "");
      let RPR = parseFloat(RPR_raw) / 100;  // e.g., 0.001000% becomes 0.00001.
      let S_min = document.getElementById("gc").checked ? 1.00 : 0.01;
      
      if (isNaN(B) || B <= 0) errors.push("Bankroll (B) must be a positive number.");
      if (isNaN(p_win) || p_win < 2 || p_win > 98) errors.push("Candidate p_win must be between 2% and 98%.");
      if (isNaN(RPR) || RPR <= 0 || RPR >= 1) errors.push("RPR must be a fraction (e.g., 0.001000%).");
      
      let p_win_frac = p_win / 100;
      let p_loss = 1 - p_win_frac;
      
      // Compute r_game from RTP:
      let r_game = 99 / p_win;
      
      // Compute the minimum IOL required:
      let IOL_min = 100 / (r_game - 1);
      if (IOL < IOL_min) {
        errors.push("Candidate IOL must be at least " + IOL_min.toFixed(2) + "% to sustain losses.");
      }
      
      // Use free variable IOL to define the escalation multiplier:
      let r_opt = 1 + (IOL / 100);
      
      // Maximum series length L (using r_opt):
      let L = Math.floor(Math.log(B / S_min + 1) / Math.log(r_opt));
      if (L < 1) L = 1;
      
      // Waiting trigger N: set such that overall ruin probability = (p_loss)^(N+L) <= RPR.
      // Solve for N: N >= ceil( ln(RPR)/ln(p_loss) ) - L.
      let N = Math.max(0, Math.ceil(Math.log(RPR) / Math.log(p_loss)) - L);
      
      // Starting bet S:
      let S = B / (Math.pow(r_opt, L) - 1);
      
      // Overall ruin probability:
      let overallRuinProb = Math.pow(p_loss, N + L);
      
      // Final remaining balance if all bets lose:
      // Total bets = S*(r_opt^L - 1)/(r_opt - 1), so final balance = B - [this amount] = B*(r_opt - 2)/(r_opt - 1)
      let finalBalance = B * (r_opt - 2) / (r_opt - 1);
      
      return {
        errors: errors,
        B: B,
        RPR: RPR,
        S_min: S_min,
        p_win: p_win,
        p_loss: p_loss,
        r_game: r_game,
        IOL: IOL,
        IOL_min: IOL_min,
        r_opt: r_opt,
        L: L,
        N: N,
        S: S,
        overallRuinProb: overallRuinProb,
        overallRuinPercent: overallRuinProb * 100,
        likelihood: Math.round(1 / overallRuinProb),
        p_win_frac: p_win_frac,
        finalBalance: finalBalance
      };
    }
    
    // --- Display Results ---
    function displayResults(params) {
      const resultsDiv = document.getElementById("results");
      
      let summaryHtml = "<h3>Optimal Strategy Results</h3>";
      summaryHtml += "<p><strong>Bankroll (B):</strong> " + params.B + "</p>";
      summaryHtml += "<p><strong>Ruin Probability Requirement (RPR):</strong> " + (params.RPR * 100).toFixed(6) + "%</p>";
      summaryHtml += "<p><strong>Optimal Win Probability (p_win):</strong> " + params.p_win.toFixed(1) + "%</p>";
      summaryHtml += "<p><strong>Game Payout Multiplier (r_game):</strong> " + params.r_game.toFixed(4) + "</p>";
      summaryHtml += "<p><strong>Chosen IOL:</strong> " + params.IOL.toFixed(2) + "% (Minimum required: " + params.IOL_min.toFixed(2) + "%)</p>";
      summaryHtml += "<p><strong>Optimal Escalation Multiplier (r_opt):</strong> " + params.r_opt.toFixed(4) + "</p>";
      summaryHtml += "<p><strong>Maximum Series Length (L):</strong> " + params.L + "</p>";
      summaryHtml += "<p><strong>Waiting Trigger (N):</strong> " + params.N + "</p>";
      summaryHtml += "<p><strong>Starting Bet (S):</strong> " + params.S.toFixed(2) + "</p>";
      summaryHtml += "<p><strong>Overall Ruin Probability:</strong> " + (params.overallRuinProb * 100).toFixed(6) + "%</p>";
      summaryHtml += "<p><strong>Likelihood of Ruin:</strong> 1/" + params.likelihood + "</p>";
      summaryHtml += "<p><strong>Final Remaining Balance (if all bets lose):</strong> " + params.finalBalance.toFixed(2) + "</p>";
      
      let toggleHtml = "<button onclick='toggleResultSummary()'>Toggle Result Summary</button>";
      toggleHtml += "<div id='resultSummary'>" + summaryHtml + "</div>";
      
      let tableHtml = buildSimulationTable(params);
      
      let explanationHtml = "<div id='explanation' style='margin-top:20px; padding:10px; border:1px solid #ccc; background-color:#f9f9f9;'>";
      explanationHtml += "<h4>Order of Operations:</h4>";
      explanationHtml += "<ol>";
      explanationHtml += "<li>RTP is fixed at 99%, so r_game = 99 / p_win.</li>";
      explanationHtml += "<li>The minimum increase on loss (IOL) is free, but must be at least IOL_min = 100/(r_game - 1).</li>";
      explanationHtml += "<li>The escalation multiplier is r_opt = 1 + (IOL/100).</li>";
      explanationHtml += "<li>Maximum series length is L = floor( ln(B/Sₘᵢₙ+1) / ln(r_opt) ).</li>";
      explanationHtml += "<li>Waiting trigger is N = max(0, ceil( ln(RPR)/ln(1 - p_win/100) ) - L), so that overall ruin probability = (p_loss)^(N+L) ≤ RPR.</li>";
      explanationHtml += "<li>Starting bet is S = B / (r_opt^L - 1).</li>";
      explanationHtml += "<li>Final remaining balance = B*(r_opt - 2)/(r_opt - 1).</li>";
      explanationHtml += "<li>The simulation chooses the candidate (p_win and IOL) that minimizes the final remaining balance (but remains > 0) while meeting the RPR threshold.</li>";
      explanationHtml += "</ol>";
      explanationHtml += "</div>";
      
      resultsDiv.innerHTML = toggleHtml + tableHtml + explanationHtml;
    }
    
    // --- Build Simulation Table ---
    // This table shows the complete loss streak:
    // First N rounds are "waiting" rounds (0 bets), then L rounds of actual bets.
    function buildSimulationTable(params) {
      let html = "<h3>Complete Loss Streak</h3>";
      html += "<table><tr>";
      html += "<th>Round #</th>";
      html += "<th>Bet Size</th>";
      html += "<th>Cumulative Bet</th>";
      html += "<th>Bet+</th>";
      html += "<th>Payout on Win</th>";
      html += "<th>Remaining Balance</th>";
      html += "<th>Balance+</th>";
      html += "</tr>";
      
      // First, add waiting rounds (N rounds with 0 bet)
      for (let i = 1; i <= params.N; i++) {
        html += "<tr>";
        html += "<td>" + i + " (Wait)</td>";
        html += "<td>0.00</td>";
        html += "<td>0.00</td>";
        // For waiting rounds, if lost, the first betting round would occur:
        html += "<td>" + params.S.toFixed(2) + "</td>";  // Bet+ equals starting bet S
        html += "<td>N/A</td>";
        html += "<td>" + params.B.toFixed(2) + "</td>";
        html += "<td>" + (params.B - params.S).toFixed(2) + "</td>";
        html += "</tr>";
      }
      
      // Then, add the actual betting rounds (L rounds)
      let cumulative = 0;
      for (let i = params.N + 1; i <= params.N + params.L; i++) {
        let j = i - params.N; // j = 1,...,L
        let bet = params.S * Math.pow(params.r_opt, j - 1);
        cumulative += bet;
        let payout = params.S * Math.pow(params.r_opt, j);
        let balance = params.B - cumulative;
        // Bet+ is the cumulative bet if the next bet is placed
        let betPlus = cumulative + payout;
        let balancePlus = params.B - betPlus;
        html += "<tr>";
        html += "<td>" + i + "</td>";
        html += "<td>" + bet.toFixed(2) + "</td>";
        html += "<td>" + cumulative.toFixed(2) + "</td>";
        html += "<td>" + betPlus.toFixed(2) + "</td>";
        html += "<td>" + payout.toFixed(2) + "</td>";
        html += "<td>" + balance.toFixed(2) + "</td>";
        html += "<td>" + balancePlus.toFixed(2) + "</td>";
        html += "</tr>";
      }
      
      html += "</table>";
      return html;
    }
    
    // --- Toggle Result Summary ---
    function toggleResultSummary() {
      const summaryDiv = document.getElementById("resultSummary");
      summaryDiv.style.display = (summaryDiv.style.display === "none") ? "block" : "none";
    }
    
    // --- Main Calculate Function (for manual calculation) ---
    function calculateOptimalStrategy() {
      let params = computeParametersCandidate(parseFloat(document.getElementById("p_win").value),
                                              parseFloat(document.getElementById("minIncrease").value));
      if (params.errors.length > 0) {
        document.getElementById("results").innerHTML = "<p class='error'>" + params.errors.join(" ") + "</p>";
        return;
      }
      displayResults(params);
    }
    
    // --- Simulation Optimization ---
    // Updated version that prioritizes minimal N, then finalBalance:
    function simulateOptimalStrategy() {
      let bestCandidate = { p_win: null, IOL: null };
      let bestCandidateN = Infinity;
      let bestFinalBalance = Infinity;
      let candidateParams;
      // Iterate candidate win probabilities from 2% to 98%
      for (let p = 2; p <= 98; p++) {
        let r_game = 99 / p;
        let IOL_min = 100 / (r_game - 1);
        for (let IOL = Math.ceil(IOL_min); IOL <= IOL_min + 500; IOL++) {
          candidateParams = computeParametersCandidate(p, IOL);
          if (candidateParams.errors.length > 0) continue;
          if (candidateParams.overallRuinProb > candidateParams.RPR) continue;
          if (candidateParams.r_opt <= 2) continue;
          // Prioritize candidate with minimal waiting trigger (N).
          if (candidateParams.N < bestCandidateN ||
              (candidateParams.N === bestCandidateN && candidateParams.finalBalance < bestFinalBalance)) {
            bestCandidateN = candidateParams.N;
            bestFinalBalance = candidateParams.finalBalance;
            bestCandidate.p_win = p;
            bestCandidate.IOL = IOL;
          }
        }
      }

      if (bestCandidate.p_win !== null) {
        let finalParams = computeParametersCandidate(bestCandidate.p_win, bestCandidate.IOL);
        displayResults(finalParams);
      } else {
        alert("No candidate combination meets the criteria.");
      }
    }
  </script>
</body>
</html>
